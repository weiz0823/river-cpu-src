# CPU设计文档

## 流水线阶段

采用经典五级流水：取指 (Instruction Fetch)，译码 (Instruction Decode)，执行 (EXEcution)，
访存 (MEMory access)，写回 (WriteBack)。
流水线阶段模块分别为`core`中的`InstructionFetch`, `InstructionDecode`, `InstructionExecute`,
`MemoryAccess`, `Writeback`，一般情况下应为纯组合逻辑，
五级流水线中间插的四组流水线寄存器分别为`IFRegs`, `IDRegs`, `EXRegs`, `MEMRegs`。

## 分支和跳转

尽可能提前分支，参考书中实现将分支和跳转计算提前至ID阶段，实现在`core.BranchDecide`模块中。
没有静态或动态分支预测，等价于预测不跳，如果预测失败（需要跳转），
那么只需要冲刷掉当前处于IF阶段的指令，并更新PC。

## 总线与握手协议

分离指令总线与数据总线，通过`bus.MemoryController`模块将3个设备连到2个总线上，
连接规则按照数据总线优先，因为数据取出来才能继续流水线运转，否则指令取出来也只能干等着。

握手协议按照valid-ready，反映为stb-ack信号，其中ack到达则代表可以撤掉当前数据，否则stb和数据需要保持。
如果需要连续的读写，可以一直保持stb，在收到ack的下个周期更换其他数据。

## 异常、中断与流水线冲刷

对通用寄存器的交付发生在WB，对内存的交付发生在MEM，对CSR的交付发生在EX。只要前序指令不发生异常、中断，当前指令即可交付。而MEM阶段异常与CSR交付互斥（不会在同一指令发生），因此只要当前MEM阶段的指令没有异常，即可交付CSR指令。
对于trap的仲裁如下：RV标准要求中断比同步异常有更高优先级。因此在中断产生时，如果MEM阶段产生异常，则打断MEM阶段指令，冲刷IF至EX的所有指令，如果没有异常，则放走MEM阶段指令，打断EX阶段指令。没有中断时，MEM阶段产生异常，则优先处理，冲刷IF至EX的所有指令；MEM阶段无异常，EX阶段有异常，则处理EX阶段异常。（时空上没有问题，因为WB阶段没有异常，这显得不符合所有指令异常推到同一阶段处理，所以需要把EX阶段异常也推到MEM吗？）

## CSR读写

由于CSR写较为复杂，对于写入不同CSR有不同处理，较难提供CSR写操作数据前推。
因此CSR寄存器读写在同一阶段，考虑到异常处理，需要放在EX阶段以避免过早产生不可挽回的副作用，影响流水线冲刷。
同时读和写在同周期完成，注意到读写是原子化的交换，所以不需要提供数据前推。
而CSR读至通用寄存器的数据前推发生在EX阶段，这也意味着下一条指令不需等待就可以在ID阶段拿到这个数据。

在实现中，CSR读写模块是`core.csr.CsrFile`，将其作为EX阶段插件即可。
这个模块将CSR纯读写指令派发给具体掌控物理CSR的模块，例如`core.csr.TrapControl`，并收集读取的值。

具体的物理CSR模块可以参照PC来实现。也即具体CSR有内部自动的状态转移，
各种控制信号导致的状态转移，CSR写指令导致的状态转移，通过内部的选择来改变CSR。
通用可例化的写处理模块在`core.csr.CsrWriteControl`。

注意以下几点：

1. 由于data的地址转换和物理地址保护需要在EX阶段进行，以保证不在MEM阶段产生异常
（例如page fault, data access misgligned），因此EX阶段可能被暂停。
则由于不能过早产生副作用，在EX阶段stall的时候不可以写入CSR寄存器，需要等待。
2. 在中断和异常同时产生时，按照标准优先选择中断，则此条指令也不能够写入CSR，因为此指令视为被打断（未执行）。
